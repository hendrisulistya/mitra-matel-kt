## All Possible Authentication Response Scenarios
### 1. Authentication Success Scenarios
âœ… Successful Authentication:

- Premium user access granted
- Regular user with active subscription access granted
### 2. Authentication Failure Scenarios (UNAUTHENTICATED - Status Code 16)
ðŸ” Token/Authorization Issues:

- AUTH_001 - "No metadata provided" (missing gRPC metadata)
- AUTH_002 - "No authorization token provided" (missing Authorization header)
- AUTH_003 - "Invalid token format" (missing "Bearer " prefix)
- AUTH_004 - "Authentication failed" (token validation failed - expired, invalid signature, etc.)
ðŸ‘¤ User/Device Issues:

- AUTH_005 - "User not found" (email in token doesn't exist in database)
- AUTH_006 - "Device ownership changed - please reauthenticate" (device mismatch)
- AUTH_007 - "Invalid device claim" (JWT claims device but user has no device)
- AUTH_008 - "Device claim required" (user has device but JWT has no device claim)
### 3. Authorization Failure Scenarios (PERMISSION_DENIED - Status Code 7)
ðŸ’³ Subscription/Tier Issues:

- SUB_001 - "No active subscription" (Regular user without active subscription)
- SUB_002 - "Invalid user tier: {tier}" (unknown/unsupported user tier)
### 4. Rate Limiting Scenarios (RESOURCE_EXHAUSTED - Status Code 8)
â° Rate Limit Issues:

- "Rate limit exceeded: {limit} requests per {window}. Try again in {retry_after}"
- "Burst limit exceeded: {limit} requests per {window}. Try again in {retry_after}"
### 5. Frontend Handling Strategy for Kotlin Android
```
classÂ GrpcAuthResponseHandlerÂ {

Â Â Â Â //Â MapÂ ofÂ errorÂ codesÂ toÂ 
Â Â Â Â user-friendlyÂ messagesÂ andÂ actions
Â Â Â Â privateÂ valÂ authErrorMapÂ =Â mapOf(
Â Â Â Â Â Â Â Â "AUTH_001"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("AuthenticationÂ required",Â 
Â Â Â Â Â Â Â Â "PleaseÂ logÂ inÂ again",Â AuthAction.
Â Â Â Â Â Â Â Â RELOGIN),
Â Â Â Â Â Â Â Â "AUTH_002"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("AuthenticationÂ required",Â 
Â Â Â Â Â Â Â Â "PleaseÂ logÂ inÂ again",Â AuthAction.
Â Â Â Â Â Â Â Â RELOGIN),
Â Â Â Â Â Â Â Â "AUTH_003"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("InvalidÂ token",Â "PleaseÂ logÂ inÂ 
Â Â Â Â Â Â Â Â again",Â AuthAction.RELOGIN),
Â Â Â Â Â Â Â Â "AUTH_004"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("SessionÂ expired",Â "PleaseÂ logÂ 
Â Â Â Â Â Â Â Â inÂ again",Â AuthAction.RELOGIN),
Â Â Â Â Â Â Â Â "AUTH_005"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("AccountÂ notÂ found",Â "ContactÂ 
Â Â Â Â Â Â Â Â support",Â AuthAction.
Â Â Â Â Â Â Â Â CONTACT_SUPPORT),
Â Â Â Â Â Â Â Â "AUTH_006"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("DeviceÂ changed",Â "PleaseÂ logÂ inÂ 
Â Â Â Â Â Â Â Â againÂ fromÂ thisÂ device",Â 
Â Â Â Â Â Â Â Â AuthAction.RELOGIN),
Â Â Â Â Â Â Â Â "AUTH_007"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("DeviceÂ issue",Â "ContactÂ 
Â Â Â Â Â Â Â Â support",Â AuthAction.
Â Â Â Â Â Â Â Â CONTACT_SUPPORT),
Â Â Â Â Â Â Â Â "AUTH_008"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("DeviceÂ required",Â "PleaseÂ logÂ 
Â Â Â Â Â Â Â Â inÂ again",Â AuthAction.RELOGIN),
Â Â Â Â Â Â Â Â "SUB_001"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("SubscriptionÂ required",Â 
Â Â Â Â Â Â Â Â "UpgradeÂ yourÂ plan",Â AuthAction.
Â Â Â Â Â Â Â Â UPGRADE_PLAN),
Â Â Â Â Â Â Â Â "SUB_002"Â toÂ AuthResponse
Â Â Â Â Â Â Â Â ("AccountÂ issue",Â "ContactÂ 
Â Â Â Â Â Â Â Â support",Â AuthAction.
Â Â Â Â Â Â Â Â CONTACT_SUPPORT)
Â Â Â Â )

Â Â Â Â funÂ handleAuthError(status:Â Status,Â 
Â Â Â Â metadata:Â Metadata?Â =Â null):Â 
Â Â Â Â AuthResponseÂ {
Â Â Â Â Â Â Â Â returnÂ whenÂ (status.code)Â {
Â Â Â Â Â Â Â Â Â Â Â Â Status.UNAUTHENTICATEDÂ ->Â 
Â Â Â Â Â Â Â Â Â Â Â Â handleUnauthenticated(status)
Â Â Â Â Â Â Â Â Â Â Â Â Status.PERMISSION_DENIEDÂ ->Â 
Â Â Â Â Â Â Â Â Â Â Â Â handlePermissionDenied(status)
Â Â Â Â Â Â Â Â Â Â Â Â Status.RESOURCE_EXHAUSTEDÂ ->Â 
Â Â Â Â Â Â Â Â Â Â Â Â handleRateLimit(status,Â 
Â Â Â Â Â Â Â Â Â Â Â Â metadata)
Â Â Â Â Â Â Â Â Â Â Â Â elseÂ ->Â AuthResponse("ServerÂ 
Â Â Â Â Â Â Â Â Â Â Â Â error",Â "PleaseÂ tryÂ againÂ 
Â Â Â Â Â Â Â Â Â Â Â Â later",Â AuthAction.RETRY)
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â privateÂ funÂ handleUnauthenticated
Â Â Â Â (status:Â Status):Â AuthResponseÂ {
Â Â Â Â Â Â Â Â //Â ExtractÂ errorÂ codeÂ fromÂ 
Â Â Â Â Â Â Â Â messageÂ ifÂ available
Â Â Â Â Â Â Â Â valÂ messageÂ =Â status.descriptionÂ ?
Â Â Â Â Â Â Â Â :Â "AuthenticationÂ failed"
Â Â Â Â Â Â Â Â valÂ errorCodeÂ =Â extractErrorCode
Â Â Â Â Â Â Â Â (message)
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â returnÂ authErrorMap[errorCode]Â ?:Â 
Â Â Â Â Â Â Â Â Â Â Â Â AuthResponse("AuthenticationÂ 
Â Â Â Â Â Â Â Â Â Â Â Â failed",Â "PleaseÂ logÂ inÂ 
Â Â Â Â Â Â Â Â Â Â Â Â again",Â AuthAction.RELOGIN)
Â Â Â Â }

Â Â Â Â privateÂ funÂ handlePermissionDenied
Â Â Â Â (status:Â Status):Â AuthResponseÂ {
Â Â Â Â Â Â Â Â valÂ messageÂ =Â status.descriptionÂ ?
Â Â Â Â Â Â Â Â :Â "AccessÂ denied"
Â Â Â Â Â Â Â Â valÂ errorCodeÂ =Â extractErrorCode
Â Â Â Â Â Â Â Â (message)
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â returnÂ authErrorMap[errorCode]Â ?:Â 
Â Â Â Â Â Â Â Â Â Â Â Â AuthResponse("AccessÂ denied",Â 
Â Â Â Â Â Â Â Â Â Â Â Â "YouÂ don'tÂ haveÂ permission",Â 
Â Â Â Â Â Â Â Â Â Â Â Â AuthAction.CONTACT_SUPPORT)
Â Â Â Â }

Â Â Â Â privateÂ funÂ handleRateLimit(status:Â 
Â Â Â Â Status,Â metadata:Â Metadata?):Â 
Â Â Â Â AuthResponseÂ {
Â Â Â Â Â Â Â Â valÂ retryAfterÂ =Â metadata?.get
Â Â Â Â Â Â Â Â (Metadata.Key.of("retry-after",Â 
Â Â Â Â Â Â Â Â Metadata.ASCII_STRING_MARSHALLER))
Â Â Â Â Â Â Â Â valÂ messageÂ =Â status.descriptionÂ ?
Â Â Â Â Â Â Â Â :Â "TooÂ manyÂ requests"
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â returnÂ AuthResponse(
Â Â Â Â Â Â Â Â Â Â Â Â "RateÂ limitÂ exceeded",Â 
Â Â Â Â Â Â Â Â Â Â Â Â message,Â 
Â Â Â Â Â Â Â Â Â Â Â Â AuthAction.RETRY_AFTER,
Â Â Â Â Â Â Â Â Â Â Â Â retryAfter?.toIntOrNull()
Â Â Â Â Â Â Â Â )
Â Â Â Â }

Â Â Â Â privateÂ funÂ extractErrorCode(message:Â 
Â Â Â Â String):Â StringÂ {
Â Â Â Â Â Â Â Â //Â ErrorÂ codesÂ areÂ inÂ formatÂ 
Â Â Â Â Â Â Â Â "AUTH_001",Â "SUB_002",Â etc.
Â Â Â Â Â Â Â Â valÂ patternÂ =Â Regex("""(AUTH|SUB)
Â Â Â Â Â Â Â Â _\d{3}""")
Â Â Â Â Â Â Â Â returnÂ pattern.find(message)?.
Â Â Â Â Â Â Â Â valueÂ ?:Â ""
Â Â Â Â }
}

dataÂ classÂ AuthResponse(
Â Â Â Â valÂ title:Â String,
Â Â Â Â valÂ message:Â String,
Â Â Â Â valÂ action:Â AuthAction,
Â Â Â Â valÂ retryAfterSeconds:Â Int?Â =Â null
)

enumÂ classÂ AuthActionÂ {
Â Â Â Â RELOGIN,Â Â Â Â Â Â Â Â Â Â Â //Â UserÂ needsÂ toÂ 
Â Â Â Â logÂ inÂ again
Â Â Â Â UPGRADE_PLAN,Â Â Â Â Â Â //Â UserÂ needsÂ toÂ 
Â Â Â Â upgradeÂ subscription
Â Â Â Â CONTACT_SUPPORT,Â Â Â //Â UserÂ shouldÂ 
Â Â Â Â contactÂ support
Â Â Â Â RETRY,Â Â Â Â Â Â Â Â Â Â Â Â Â //Â UserÂ canÂ retryÂ 
Â Â Â Â theÂ operation
Â Â Â Â RETRY_AFTERÂ Â Â Â Â Â Â Â //Â UserÂ shouldÂ 
Â Â Â Â retryÂ afterÂ specifiedÂ seconds
}

//Â UsageÂ example:
funÂ handleGrpcError(exception:Â Exception)Â 
{
Â Â Â Â valÂ statusÂ =Â Status.fromThrowable
Â Â Â Â (exception)
Â Â Â Â valÂ handlerÂ =Â GrpcAuthResponseHandler
Â Â Â Â ()
Â Â Â Â valÂ responseÂ =Â handler.handleAuthError
Â Â Â Â (status)
Â Â Â Â 
Â Â Â Â whenÂ (response.action)Â {
Â Â Â Â Â Â Â Â AuthAction.RELOGINÂ ->Â 
Â Â Â Â Â Â Â Â showLoginScreen(response.message)
Â Â Â Â Â Â Â Â AuthAction.UPGRADE_PLANÂ ->Â 
Â Â Â Â Â Â Â Â showUpgradeDialog(response.
Â Â Â Â Â Â Â Â message)
Â Â Â Â Â Â Â Â AuthAction.CONTACT_SUPPORTÂ ->Â 
Â Â Â Â Â Â Â Â showSupportContact(response.
Â Â Â Â Â Â Â Â message)
Â Â Â Â Â Â Â Â AuthAction.RETRYÂ ->Â 
Â Â Â Â Â Â Â Â showRetryButton(response.message)
Â Â Â Â Â Â Â Â AuthAction.RETRY_AFTERÂ ->Â 
Â Â Â Â Â Â Â Â showRetryTimer(response.message,Â 
Â Â Â Â Â Â Â Â response.retryAfterSecondsÂ ?:Â 30)
Â Â Â Â }
}
```
### 6. User Tier-Based Access Rules
- Premium Users : Full access without subscription checks
- Regular Users : Requires active subscription ( status = "active" AND end_date > now() )
- Invalid Tier : Contact support required
### 7. Device Security Enforcement
- Device claims in JWT must match user's registered device
- Prevents token sharing across devices
- Forces reauthentication on device changes
### 8. Cache Behavior
- User data cached for 1 hour (UserCacheTTL)
- Subscription status cached for 24 hours (SubscriptionCacheTTL)
- Cache invalidated on device/location changes
This comprehensive error handling strategy ensures your Android app can:

- Show appropriate user-friendly messages
- Guide users to correct actions (login, upgrade, contact support)
- Handle rate limiting with retry timers
- Maintain device security compliance
- Provide clear troubleshooting paths for different error scenarios